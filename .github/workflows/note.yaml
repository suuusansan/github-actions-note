name: Note Workflow

on:
  workflow_dispatch:
    inputs:
      theme:
        description: 'è¨˜äº‹ãƒ†ãƒ¼ãƒ'
        required: true
        type: string
      target:
        description: 'æƒ³å®šèª­è€…ï¼ˆãƒšãƒ«ã‚½ãƒŠï¼‰'
        required: true
        type: string
      message:
        description: 'èª­è€…ã«ä¼ãˆãŸã„æ ¸ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸'
        required: true
        type: string
      cta:
        description: 'èª­å¾Œã®ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ï¼ˆCTAï¼‰'
        required: true
        type: string
      tags:
        description: 'ã‚«ãƒ³ãƒåŒºåˆ‡ã‚Šã‚¿ã‚°ï¼ˆä»»æ„ï¼‰'
        required: false
        default: ''
        type: string
      is_public:
        description: 'å…¬é–‹(true)/ä¸‹æ›¸ã(false)'
        required: true
        default: 'false'
        type: choice
        options: ['true','false']
      dry_run:
        description: 'æŠ•ç¨¿ã‚’ã‚¹ã‚­ãƒƒãƒ—ï¼ˆç”Ÿæˆã®ã¿ï¼‰'
        required: true
        default: 'false'
        type: choice
        options: ['true','false']

permissions:
  contents: read

env:
  TZ: Asia/Tokyo

# =========================
# Research: Tavily + Gemini
# =========================
jobs:
  research:
    name: Research (Tavily + Gemini)
    runs-on: ubuntu-latest
    env:
      GOOGLE_GENERATIVE_AI_API_KEY: ${{ secrets.GOOGLE_GENERATIVE_AI_API_KEY }}
      TAVILY_API_KEY: ${{ secrets.TAVILY_API_KEY }}
      THEME: ${{ github.event.inputs.theme }}
      TARGET: ${{ github.event.inputs.target }}
    outputs:
      research_b64: ${{ steps.collect.outputs.research_b64 }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install AI SDK (Gemini)
        run: |
          npm init -y
          npm i ai @ai-sdk/google

      - name: List available Gemini models (debug)
        run: |
          curl -s "https://generativelanguage.googleapis.com/v1beta/models?key=${GOOGLE_GENERATIVE_AI_API_KEY}" \
          | jq -r '.models[].name' | head -n 50


      - name: Research with Tavily + Gemini
        run: |
          cat > research.mjs <<'EOF'
          import fs from 'fs';
          import { generateText } from 'ai';
          import { google } from '@ai-sdk/google';

          const theme = process.env.THEME || '';
          const target = process.env.TARGET || '';
          const today = new Date().toISOString().slice(0,10);
          const TAVILY_API_KEY = process.env.TAVILY_API_KEY || '';
          const modelName = 'gemini-2.5-pro';
          const artifactsDir = '.note-artifacts';
          fs.mkdirSync(artifactsDir, { recursive: true });

          async function tavilySearch(q) {
            const res = await fetch('https://api.tavily.com/search', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                api_key: TAVILY_API_KEY,
                query: q,
                search_depth: 'advanced',
                max_results: 8,
                include_answer: true
              })
            });
            if (!res.ok) return [];
            const json = await res.json().catch(()=>({results:[]}));
            return Array.isArray(json.results) ? json.results : [];
          }

          async function proposeQueries(topic, persona) {
            const sys = 'å…¥åŠ›ãƒ†ãƒ¼ãƒã«å¯¾ã™ã‚‹æœ€æ–°æƒ…å ±åé›†ç”¨ã®æ—¥æœ¬èªWebæ¤œç´¢ã‚¯ã‚¨ãƒªã‚’æœ€å¤§10ä»¶ã®JSONé…åˆ—ã®ã¿ã§è¿”ç­”ã€‚ä¸€æ¬¡æƒ…å ±ï¼ˆå…¬çš„æ©Ÿé–¢ãƒ»è¦æ ¼ãƒ»è«–æ–‡ãƒ»å…¬å¼ï¼‰ã‚’å„ªå…ˆã™ã‚‹èªã‚’å«ã‚ã‚‹ã“ã¨ã€‚';
            const prompt = `ãƒ†ãƒ¼ãƒ: ${topic}\nã‚¿ãƒ¼ã‚²ãƒƒãƒˆ: ${persona}\nç¾åœ¨æ—¥ä»˜: ${today}`;
            const { text } = await generateText({
              model: google(modelName),
              system: sys,
              prompt,
              temperature: 0,
              maxTokens: 2000
            });
            try {
              const t = (text || '').trim().replace(/```[a-zA-Z]*|```/g,'');
              const arr = JSON.parse(t);
              return Array.isArray(arr) ? arr.map(String).slice(0,10) : [];
            } catch { return []; }
          }

          function renderEvidenceMD(blocks) {
            const lines = [];
            for (const b of blocks) {
              lines.push(`### æ¤œç´¢: ${b.query}`);
              for (const r of b.results) {
                const t = (r.title || r.url);
                const u = r.url;
                const c = (r.content || '').slice(0, 400).replace(/\s+/g,' ').trim();
                lines.push(`- [${t}](${u})  \n  ${c}`);
              }
              lines.push('');
            }
            return lines.join('\n');
          }

          async function main() {
            if (!TAVILY_API_KEY) { console.error('TAVILY_API_KEY is not set'); process.exit(1); }

            const queries = await proposeQueries(theme, target);
            const blocks = [];
            for (const q of queries) {
              const results = await tavilySearch(q);
              if (results.length) blocks.push({ query: q, results });
            }

            const sys = [
              'ã‚ãªãŸã¯æœ€æ–°æƒ…å ±ã®åé›†ã¨è¦ç´„ã«ç‰¹åŒ–ã—ãŸä¸€æµã®ãƒªã‚µãƒ¼ãƒãƒ£ãƒ¼ã§ã™ã€‚',
              'äº‹å®Ÿãƒ™ãƒ¼ã‚¹ãƒ»ä¸€æ¬¡æƒ…å ±å„ªå…ˆã€‚æœ¬æ–‡ã« Markdown ãƒªãƒ³ã‚¯ã§å‡ºå…¸ã‚’åŸ‹ã‚è¾¼ã‚€ã“ã¨ã€‚',
              'å„ç¯€ã«å°è¦‹å‡ºã—ã€‚ååˆ†ãªåˆ†é‡ï¼ˆç›®å®‰: 2,000èªä»¥ä¸Šï¼‰ã€‚'
            ].join('\n');

            const prompt = [
              `ãƒ†ãƒ¼ãƒ: ${theme}`,
              `ã‚¿ãƒ¼ã‚²ãƒƒãƒˆ: ${target}`,
              `ç¾åœ¨æ—¥ä»˜: ${today}`,
              '',
              '## åé›†ã‚¨ãƒ“ãƒ‡ãƒ³ã‚¹ï¼ˆURLã¨è¦ç´„ï¼‰',
              renderEvidenceMD(blocks)
            ].join('\n');

            const { text } = await generateText({
              model: google(modelName),
              system: sys,
              prompt,
              temperature: 0.2,
              maxTokens: 30000
            });

            fs.writeFileSync(`${artifactsDir}/research.md`, String(text||'').trim());
            try { fs.writeFileSync(`${artifactsDir}/research_trace.json`, JSON.stringify({ queries, blocks }, null, 2)); } catch {}
          }

          await main();
          EOF
          node research.mjs

      - name: Collect research
        id: collect
        run: |
          b64=$(base64 -w 0 .note-artifacts/research.md 2>/dev/null || base64 .note-artifacts/research.md)
          echo "research_b64<<EOF" >> $GITHUB_OUTPUT
          echo "$b64" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Upload research artifacts
        uses: actions/upload-artifact@v4
        with:
          name: research-artifacts
          path: |
            .note-artifacts/research.md
            .note-artifacts/research_trace.json

# =====================
# Write: Gemini ã‚’ä½¿ç”¨
# =====================
  write:
    name: Write (Gemini 1.5 Pro)
    needs: research
    runs-on: ubuntu-latest
    env:
      GOOGLE_GENERATIVE_AI_API_KEY: ${{ secrets.GOOGLE_GENERATIVE_AI_API_KEY }}
      THEME: ${{ github.event.inputs.theme }}
      TARGET: ${{ github.event.inputs.target }}
      MESSAGE: ${{ github.event.inputs.message }}
      CTA: ${{ github.event.inputs.cta }}
      INPUT_TAGS: ${{ github.event.inputs.tags }}
    outputs:
      title: ${{ steps.collect.outputs.title }}
      draft_json_b64: ${{ steps.collect.outputs.draft_json_b64 }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install AI SDK (Gemini)
        run: |
          npm init -y
          npm i ai @ai-sdk/google

      - name: Restore research
        env:
          RESEARCH_B64: ${{ needs.research.outputs.research_b64 }}
        run: |
          mkdir -p .note-artifacts
          echo "$RESEARCH_B64" | base64 -d > .note-artifacts/research.md || echo "$RESEARCH_B64" | base64 --decode > .note-artifacts/research.md

      - name: Generate draft (title/body/tags)
        run: |
          cat > write.mjs <<'EOF'
          import { generateText } from 'ai';
          import { google } from '@ai-sdk/google';
          import fs from 'fs';
          const theme=process.env.THEME||''; const target=process.env.TARGET||''; const message=process.env.MESSAGE||''; const cta=process.env.CTA||'';
          const inputTags=(process.env.INPUT_TAGS||'').split(',').map(s=>s.trim()).filter(Boolean);
          const researchReport=fs.readFileSync('.note-artifacts/research.md','utf8');
          const modelName='gemini-2.5-pro';
          function extractJsonFlexible(raw){const t=(raw||'').trim().replace(/\u200B/g,'');try{return JSON.parse(t);}catch{}const m=t.match(/```[a-zA-Z]*\s*([\s\S]*?)\s*```/);if(m&&m[1]){try{return JSON.parse(m[1].trim());}catch{}}const f=t.indexOf('{'),l=t.lastIndexOf('}');if(f!==-1&&l!==-1&&l>f){const c=t.slice(f,l+1);try{return JSON.parse(c);}catch{}}return null;}
          async function repairJson(raw){const sys='å…¥åŠ›ã‹ã‚‰ {"title":string,"draftBody":string,"tags":string[]} ã®JSONã®ã¿è¿”ç­”ã€‚';const {text}=await generateText({model:google(modelName),system:sys,prompt:String(raw),temperature:0,maxTokens:8000});return extractJsonFlexible(text||'');}
          function sanitizeTitle(t){let s=String(t||'').trim();s=s.replace(/^```[a-zA-Z0-9_-]*\s*$/,'').replace(/^```$/,'');s=s.replace(/^#+\s*/,'');s=s.replace(/^"+|"+$/g,'').replace(/^'+|'+$/g,'');s=s.replace(/^`+|`+$/g,'');s=s.replace(/^json$/i,'').trim();if(!s) s='ã‚¿ã‚¤ãƒˆãƒ«ï¼ˆè‡ªå‹•ç”Ÿæˆï¼‰';return s;}
          function deriveTitleFromText(text){const lines=(text||'').split(/\r?\n/).map(l=>l.trim()).filter(Boolean);const firstReal=lines.find(l=>!/^```/.test(l))||lines[0]||'';return sanitizeTitle(firstReal);}
          const sysWrite='note.comå‘ã‘é•·æ–‡è¨˜äº‹ã®ç”Ÿæˆã€‚JSON {title,draftBody,tags[]} ã§è¿”ç­”ã€‚draftBodyã¯6000ã€œ9000æ–‡å­—ã‚’ç›®å®‰ã«ååˆ†ãªåˆ†é‡ã§ã€ç« ã”ã¨ã«å°è¦‹å‡ºã—ã¨ç®‡æ¡æ›¸ãã‚’é©åˆ‡ã«å«ã‚ã‚‹ã“ã¨ã€‚';
          const prompt=[`{ãƒ†ãƒ¼ãƒ}: ${theme}`,`{ãƒšãƒ«ã‚½ãƒŠ}: ${target}`,`{ãƒªã‚µãƒ¼ãƒå†…å®¹}: ${researchReport}`,`{ä¼ãˆãŸã„ã“ã¨}: ${message}`,`{èª­å¾Œã®ã‚¢ã‚¯ã‚·ãƒ§ãƒ³}: ${cta}`].join('\n');
          const {text}=await generateText({model:google(modelName),system:sysWrite,prompt,temperature:0.7,maxTokens:30000});
          let obj=extractJsonFlexible(text||'')||await repairJson(text||'');
          let title, draftBody, tags; if(obj){title=sanitizeTitle(obj.title); draftBody=String(obj.draftBody||'').trim(); tags=Array.isArray(obj.tags)?obj.tags.map(String):[]}
          if(!title||!draftBody){ title=deriveTitleFromText(text||''); const lines=(text||'').split(/\r?\n/); draftBody=lines.slice(1).join('\n').trim()||(text||''); tags=[]}
          if(inputTags.length){tags=Array.from(new Set([...(tags||[]),...inputTags]));}
          fs.writeFileSync('.note-artifacts/draft.json',JSON.stringify({title,draftBody,tags},null,2));
          EOF
          node write.mjs

      - name: Collect draft
        id: collect
        run: |
          title=$(node -e "console.log(JSON.parse(require('fs').readFileSync('.note-artifacts/draft.json','utf8')).title)")
          b64=$(base64 -w 0 .note-artifacts/draft.json 2>/dev/null || base64 .note-artifacts/draft.json)
          echo "title<<EOF" >> $GITHUB_OUTPUT
          echo "$title" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          echo "draft_json_b64<<EOF" >> $GITHUB_OUTPUT
          echo "$b64" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Upload draft artifact
        uses: actions/upload-artifact@v4
        with:
          name: draft-artifact
          path: .note-artifacts/draft.json

# ======================
# Fact-check: Gemini ä½¿ç”¨
# ======================
  factcheck:
    name: Fact-check (Tavily + Gemini)
    needs: write
    runs-on: ubuntu-latest
    env:
      GOOGLE_GENERATIVE_AI_API_KEY: ${{ secrets.GOOGLE_GENERATIVE_AI_API_KEY }}
      TAVILY_API_KEY: ${{ secrets.TAVILY_API_KEY }}
      TITLE: ${{ needs.write.outputs.title }}
    outputs:
      title: ${{ steps.collect.outputs.title }}
      final_b64: ${{ steps.collect.outputs.final_b64 }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install AI SDK (Gemini)
        run: |
          npm init -y
          npm i ai @ai-sdk/google

      - name: Restore draft json
        env:
          DRAFT_JSON_B64: ${{ needs.write.outputs.draft_json_b64 }}
        run: |
          mkdir -p .note-artifacts
          echo "$DRAFT_JSON_B64" | base64 -d > .note-artifacts/draft.json || echo "$DRAFT_JSON_B64" | base64 --decode > .note-artifacts/draft.json

      - name: Fact-check with Tavily + Gemini
        run: |
          cat > factcheck.mjs <<'EOF'
          import { generateText } from 'ai';
          import { google } from '@ai-sdk/google';
          import fs from 'fs';
          const draft=JSON.parse(fs.readFileSync('.note-artifacts/draft.json','utf8'));
          const modelName='gemini-2.5-pro';
          const TAVILY_API_KEY=process.env.TAVILY_API_KEY||'';
          if(!TAVILY_API_KEY){ console.error('TAVILY_API_KEY is not set'); process.exit(1); }

          function extractJsonFlexible(raw){
            const t=(raw||'').trim().replace(/\u200B/g,'');
            try{ const o=JSON.parse(t); return o; }catch{}
            const fence=t.match(/```[a-zA-Z]*\s*([\s\S]*?)\s*```/); if(fence&&fence[1]){ try{ return JSON.parse(fence[1].trim()); }catch{} }
            let f=t.indexOf('{'), l=t.lastIndexOf('}'); if(f!==-1&&l!==-1&&l>f){ const cand=t.slice(f,l+1); try{ return JSON.parse(cand); }catch{} }
            f=t.indexOf('['); l=t.lastIndexOf(']'); if(f!==-1&&l!==-1&&l>f){ const cand=t.slice(f,l+1); try{ return JSON.parse(cand); }catch{} }
            return null;
          }
          function stripCodeFence(s){
            const t=String(s||'').trim();
            const m=t.match(/^```[a-zA-Z0-9_-]*\s*([\s\S]*?)\s*```\s*$/); if(m&&m[1]) return m[1].trim();
            return t;
          }

          async function proposeQueries(body){
            const sys='ã‚ãªãŸã¯äº‹å®Ÿæ¤œè¨¼ã®å°‚é–€å®¶ã§ã™ã€‚å…¥åŠ›æœ¬æ–‡ã‹ã‚‰æ¤œè¨¼ãŒå¿…è¦ãªå›ºæœ‰åè©ãƒ»æ•°å€¤ãƒ»ä¸»å¼µã‚’æŠ½å‡ºã—ã€Tavilyæ¤œç´¢ç”¨ã«æ—¥æœ¬èªã®æ¤œç´¢ã‚¯ã‚¨ãƒªã‚’æœ€å¤§10ä»¶ã®é…åˆ—ã§è¿”ã—ã¦ãã ã•ã„ã€‚å‡ºåŠ›ã¯JSONé…åˆ—ã®ã¿ã€‚';
            const { text } = await generateText({ model: google(modelName), system: sys, prompt: String(body), temperature: 0, maxTokens: 2000 });
            const arr = extractJsonFlexible(text||'');
            return Array.isArray(arr) ? arr.map(String).filter(Boolean).slice(0,10) : [];
          }

          async function tavilySearch(q){
            const res = await fetch('https://api.tavily.com/search', {
              method: 'POST', headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ api_key: TAVILY_API_KEY, query: q, search_depth: 'advanced', max_results: 5, include_answer: true })
            });
            if(!res.ok){ return { query:q, results:[], answer:null }; }
            const json = await res.json().catch(()=>({}));
            return { query:q, results: Array.isArray(json.results)? json.results: [], answer: json.answer || null };
          }

          function formatEvidence(items){
            const lines = [];
            for(const it of items){
              lines.push(`### æ¤œç´¢: ${it.query}`);
              if(it.answer){ lines.push(`è¦ç´„: ${it.answer}`); }
              for(const r of it.results||[]){
                const t = (r.title||'').toString();
                const u = (r.url||'').toString();
                const c = (r.content||'').toString().slice(0,500);
                lines.push(`- [${t}](${u})\n  ${c}`);
              }
              lines.push('');
            }
            return lines.join('\n');
          }

          async function main(){
            const queries = await proposeQueries(draft.draftBody||'');
            const results = [];
            for(const q of queries){ results.push(await tavilySearch(q)); }
            const evidence = formatEvidence(results);
            const sys=[
              'ã‚ãªãŸã¯äº‹å®Ÿæ¤œè¨¼ã®å°‚é–€å®¶ã§ã™ã€‚ä»¥ä¸‹ã®åŸç¨¿ï¼ˆnoteè¨˜äº‹ã®ä¸‹æ›¸ãï¼‰ã«å¯¾ã—ã€æä¾›ã•ã‚ŒãŸã‚¨ãƒ“ãƒ‡ãƒ³ã‚¹ï¼ˆTavilyæ¤œç´¢çµæœï¼‰ã«åŸºã¥ãã€',
              'èª¤æƒ…å ±ã®ä¿®æ­£ãƒ»ä½ä¿¡é ¼å‡ºå…¸ã®ç½®æ›ãƒ»ä¿¡é ¼ã§ãã‚‹ä¸€æ¬¡æƒ…å ±ã®æœ¬æ–‡å†…Markdownãƒªãƒ³ã‚¯åŸ‹ã‚è¾¼ã¿ã‚’è¡Œã£ã¦ã€ä¿®æ­£å¾Œã®æœ¬æ–‡ã®ã¿è¿”ã—ã¦ãã ã•ã„ã€‚',
              'æ–‡ä½“ãƒ»æ§‹æˆã¯åŸç¨¿ã‚’å°Šé‡ã—ã€å¿…è¦ã«å¿œã˜ã¦æœ¬æ–‡æœ«å°¾ã«å‚è€ƒæ–‡çŒ®ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã‚’è¿½åŠ ã—ã¦ãã ã•ã„ã€‚',
            ].join('\n');
            const prompt = [
              '## åŸç¨¿', String(draft.draftBody||''), '', '## ã‚¨ãƒ“ãƒ‡ãƒ³ã‚¹ï¼ˆTavilyæ¤œç´¢çµæœï¼‰', evidence
            ].join('\n\n');
            const { text } = await generateText({ model: google(modelName), system: sys, prompt, temperature: 0.3, maxTokens: 30000 });
            let body = stripCodeFence(text||'');
            let title = process.env.TITLE || draft.title || '';
            let tags = Array.isArray(draft.tags)? draft.tags: [];
            const obj = extractJsonFlexible(body);
            if (obj && typeof obj === 'object' && !Array.isArray(obj)) {
              if (obj.title) title = String(obj.title);
              const candidates = [obj.body, obj.draftBody, obj.content, obj.text];
              const chosen = candidates.find(v=>typeof v==='string' && v.trim());
              if (chosen) body = String(chosen);
              if (Array.isArray(obj.tags)) tags = obj.tags.map(String);
            }
            body = stripCodeFence(body);
            const out = { title, body, tags };
            fs.writeFileSync('.note-artifacts/final.json', JSON.stringify(out,null,2));
          }

          await main();
          EOF
          node factcheck.mjs

      - name: Upload fact-check artifact
        uses: actions/upload-artifact@v4
        with:
          name: final-artifact
          path: .note-artifacts/final.json

      - name: Collect final
        id: collect
        run: |
          title=$(node -e "console.log(JSON.parse(require('fs').readFileSync('.note-artifacts/final.json','utf8')).title)")
          b64=$(base64 -w 0 .note-artifacts/final.json 2>/dev/null || base64 .note-artifacts/final.json)
          echo "title<<EOF" >> $GITHUB_OUTPUT
          echo "$title" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          echo "final_b64<<EOF" >> $GITHUB_OUTPUT
          echo "$b64" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

# =========================
# Post: æ—¢å­˜ã® Playwright ã§æŠ•ç¨¿
# =========================
  post:
    name: Post to note.com (Playwright)
    needs: factcheck
    if: ${{ github.event.inputs.dry_run != 'true' }}
    runs-on: ubuntu-latest
    env:
      IS_PUBLIC: ${{ github.event.inputs.is_public }}
      STATE_JSON: ${{ secrets.NOTE_STORAGE_STATE_JSON }}
      START_URL: https://editor.note.com/new
    outputs:
      final_url: ${{ steps.publish.outputs.published_url || steps.publish.outputs.draft_url }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install Playwright
        run: |
          npm init -y
          npm i playwright marked
          npx playwright install --with-deps chromium | cat

      - name: Prepare storageState
        id: state
        run: |
          test -n "$STATE_JSON" || (echo "ERROR: NOTE_STORAGE_STATE_JSON secret is not set" && exit 1)
          mkdir -p "$RUNNER_TEMP"
          echo "$STATE_JSON" > "$RUNNER_TEMP/note-state.json"
          echo "STATE_PATH=$RUNNER_TEMP/note-state.json" >> $GITHUB_OUTPUT

      - name: Ensure jq (post)
        run: |
          if ! command -v jq >/dev/null 2>&1; then
            sudo apt-get update -y
            sudo apt-get install -y jq
          fi

      - name: Restore final
        id: draft
        env:
          FINAL_B64: ${{ needs.factcheck.outputs.final_b64 }}
        run: |
          test -n "$FINAL_B64" || { echo "final_b64 output is empty"; exit 1; }
          echo "$FINAL_B64" | base64 -d > final.json || echo "$FINAL_B64" | base64 --decode > final.json
          echo "TITLE=$(jq -r .title final.json)" >> $GITHUB_OUTPUT
          echo "TAGS=$(jq -r '.tags | join(", ")' final.json)" >> $GITHUB_OUTPUT
        #      - name: Publish via Playwright (draft or public)
        #        id: publish
        #        env:
        #          TITLE: ${{ steps.draft.outputs.TITLE }}
        #          TAGS: ${{ steps.draft.outputs.TAGS }}
        #          STATE_PATH: ${{ steps.state.outputs.STATE_PATH }}
        #          run: |
        #          # ã“ã“ã¯å…ƒã®æŠ•ç¨¿ãƒ­ã‚¸ãƒƒã‚¯ãã®ã¾ã¾ã§OKï¼ˆé•·ã„ã®ã§å‰²æ„›ï¼‰
        #            node -e "console.log('Ready to post. Plug in your existing post.mjs if needed.')" || true
        #
        
      - name: Publish via Playwright (draft or public)
        id: publish
        env:
          TITLE: ${{ steps.draft.outputs.TITLE }}
          TAGS: ${{ steps.draft.outputs.TAGS }}
          STATE_PATH: ${{ steps.state.outputs.STATE_PATH }}
          IS_PUBLIC: ${{ github.event.inputs.is_public }}
          # æœ¬æ–‡ã‚’JSONãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰èª­ã¿è¾¼ã‚€ãŸã‚ãƒ‘ã‚¹ã‚’æŒ‡å®š
          FINAL_JSON_PATH: final.json 
        run: |
          cat > post.mjs <<'EOF'
          import { chromium } from 'playwright';
          import fs from 'fs';

          // --- è¨­å®šèª­ã¿è¾¼ã¿ ---
          const isPublic = process.env.IS_PUBLIC === 'true';
          const statePath = process.env.STATE_PATH;
          const finalJsonPath = 'final.json'; // å‰ã®ã‚¹ãƒ†ãƒƒãƒ—ã§ç”Ÿæˆã•ã‚ŒãŸãƒ•ã‚¡ã‚¤ãƒ«
          
          // æœ¬æ–‡ã‚’ãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰å®‰å…¨ã«èª­ã¿è¾¼ã‚€ï¼ˆç’°å¢ƒå¤‰æ•°ã ã¨æ”¹è¡ŒãŒå£Šã‚Œã‚‹ã“ã¨ãŒã‚ã‚‹ãŸã‚ï¼‰
          let draftBody = '';
          let title = process.env.TITLE || '';
          let tagsStr = process.env.TAGS || '';
          
          try {
            if (fs.existsSync(finalJsonPath)) {
              const data = JSON.parse(fs.readFileSync(finalJsonPath, 'utf8'));
              draftBody = data.body || '';
              if (!title) title = data.title || '';
              if (!tagsStr && data.tags) tagsStr = data.tags.join(', ');
            }
          } catch (e) {
            console.error('JSONèª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼:', e);
          }

          if (!draftBody) {
             console.error('ã€è‡´å‘½çš„ã‚¨ãƒ©ãƒ¼ã€‘æœ¬æ–‡ãŒç©ºã§ã™ã€‚æŠ•ç¨¿ã‚’ä¸­æ­¢ã—ã¾ã™ã€‚');
             process.exit(1);
          }

          (async () => {
            console.log(`ğŸš€ èµ·å‹•: ${isPublic ? 'å…¬é–‹ãƒ¢ãƒ¼ãƒ‰' : 'ä¸‹æ›¸ããƒ¢ãƒ¼ãƒ‰'}`);
            console.log(`ã‚¿ã‚¤ãƒˆãƒ«: ${title}`);

            // ãƒ–ãƒ©ã‚¦ã‚¶èµ·å‹•ï¼ˆstorageStateã§ãƒ­ã‚°ã‚¤ãƒ³ç¶­æŒï¼‰
            const browser = await chromium.launch({ headless: true });
            const context = await browser.newContext({
              storageState: statePath,
              viewport: { width: 1280, height: 800 },
              userAgent: 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36'
            });
            
            const page = await context.newPage();

            try {
              // 1. ã‚¨ãƒ‡ã‚£ã‚¿ã‚’é–‹ã
              console.log('ã‚¨ãƒ‡ã‚£ã‚¿ã«ã‚¢ã‚¯ã‚»ã‚¹ä¸­...');
              await page.goto('https://editor.note.com/new', { waitUntil: 'domcontentloaded' });
              
              // ãƒ­ã‚°ã‚¤ãƒ³ç¢ºèªï¼ˆãƒ­ã‚°ã‚¤ãƒ³ç”»é¢ã«é£›ã°ã•ã‚Œã¦ã„ãŸã‚‰ã‚¨ãƒ©ãƒ¼ï¼‰
              if (page.url().includes('/login')) {
                throw new Error('ãƒ­ã‚°ã‚¤ãƒ³ã§ãã¦ã„ã¾ã›ã‚“ã€‚STATE_JSONã®æœŸé™åˆ‡ã‚Œã‹ã€è¨­å®šãƒŸã‚¹ã§ã™ã€‚');
              }

              // 2. ã‚¿ã‚¤ãƒˆãƒ«å…¥åŠ›
              console.log('ã‚¿ã‚¤ãƒˆãƒ«å…¥åŠ›ä¸­...');
              const titleInput = page.getByPlaceholder('è¨˜äº‹ã‚¿ã‚¤ãƒˆãƒ«');
              await titleInput.click();
              await titleInput.fill(title);

              // 3. æœ¬æ–‡å…¥åŠ›
              console.log('æœ¬æ–‡å…¥åŠ›ä¸­...');
              
              // ã€ä¿®æ­£ã€‘ã‚¯ãƒ©ã‚¹å ".editor-input-area" ã¯å¤ã„å¯èƒ½æ€§ãŒã‚ã‚‹ãŸã‚å¤‰æ›´
              // Noteã®ã‚¨ãƒ‡ã‚£ã‚¿ã¯ "ProseMirror" ã¨ã„ã†ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‚’ä½¿ã£ã¦ã„ã‚‹ãŸã‚ã€ã“ã®ã‚¯ãƒ©ã‚¹ã‚’ç‹™ã„ã¾ã™
              const editor = page.locator('div.ProseMirror').first();
              
              // ã‚¨ãƒ‡ã‚£ã‚¿ãŒè¦‹ã¤ã‹ã‚‹ã¾ã§å¾…æ©Ÿ
              try {
                await editor.waitFor({ state: 'visible', timeout: 10000 });
                await editor.click();
              } catch (e) {
                console.log('ProseMirrorãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚åˆ¥ã®æ–¹æ³•("æœ¬æ–‡ã‚’å…¥åŠ›"ã®æ–‡å­—)ã§æ¢ã—ã¾ã™...');
                // ä»£æ›¿ç­–: ãƒ—ãƒ¬ãƒ¼ã‚¹ãƒ›ãƒ«ãƒ€ãƒ¼ã®æ–‡å­—ã‚’ã‚¯ãƒªãƒƒã‚¯
                await page.getByText('æœ¬æ–‡ã‚’å…¥åŠ›').click();
              }

              // å…¥åŠ›
              await page.keyboard.type(draftBody, { delay: 1 }); 
              
              await page.waitForTimeout(1000);
              
              await page.waitForTimeout(1000);

              // 4. ãƒãƒƒã‚·ãƒ¥ã‚¿ã‚°å…¥åŠ›ï¼ˆã‚‚ã—ã‚ã‚Œã°ï¼‰
              if (tagsStr) {
                console.log('ã‚¿ã‚°è¨­å®šä¸­...');
                // å…¬é–‹è¨­å®šç”»é¢ã§ã‚„ã‚‹ã®ãŒç¢ºå®Ÿã§ã™ãŒã€ã“ã“ã§ã¯ç°¡æ˜“çš„ã«ã€Œå…¬é–‹è¨­å®šã€ãƒœã‚¿ãƒ³ã‚’æŠ¼ã—ãŸå¾Œã®ç”»é¢ã§å‡¦ç†ã™ã‚‹å‰æ
                // â€»ãƒ•ãƒ­ãƒ¼ãŒè¤‡é›‘ã«ãªã‚‹ãŸã‚ã€ä»Šå›ã¯ã€Œå…¬é–‹è¨­å®šã€ç”»é¢ã§ã®å…¥åŠ›ã¯çœç•¥ã—ã€æœ¬æ–‡æœ«å°¾ã«è¿½åŠ ã™ã‚‹ç­‰ã®é‹ç”¨ã§ã‚«ãƒãƒ¼æ¨å¥¨ã§ã™ãŒ
                // noteã®UIã§ã¯ã€Œå…¬é–‹è¨­å®šã€ãƒœã‚¿ãƒ³ã‚’æŠ¼ã—ãŸå¾Œã®ãƒ¢ãƒ¼ãƒ€ãƒ«ã§ã‚¿ã‚°ã‚’å…¥ã‚Œã‚‹ã®ãŒä¸€èˆ¬çš„ã§ã™ã€‚
              }

              // 5. ä¿å­˜/å…¬é–‹å‡¦ç†
              if (isPublic) {
                console.log('ğŸ”¥ å…¬é–‹å‡¦ç†ã‚’é–‹å§‹...');
                await page.getByRole('button', { name: 'å…¬é–‹è¨­å®š' }).click();
                
                // ãƒãƒƒã‚·ãƒ¥ã‚¿ã‚°å…¥åŠ›ï¼ˆå…¬é–‹è¨­å®šãƒ¢ãƒ¼ãƒ€ãƒ«å†…ï¼‰
                if (tagsStr) {
                   await page.waitForSelector('input[placeholder="ãƒãƒƒã‚·ãƒ¥ã‚¿ã‚°ã‚’è¿½åŠ "]', { timeout: 5000 }).catch(()=>console.log('ã‚¿ã‚°å…¥åŠ›æ¬„è¦‹ã¤ã‹ã‚‰ãš'));
                   const tagInput = page.getByPlaceholder('ãƒãƒƒã‚·ãƒ¥ã‚¿ã‚°ã‚’è¿½åŠ ');
                   if (await tagInput.isVisible()) {
                      const tags = tagsStr.split(',').map(t => t.trim());
                      for (const tag of tags) {
                        await tagInput.fill(tag);
                        await page.keyboard.press('Enter');
                        await page.waitForTimeout(500);
                      }
                   }
                }

                // æœ€çµ‚çš„ãªã€ŒæŠ•ç¨¿ã€ãƒœã‚¿ãƒ³ï¼ˆUIã«ã‚ˆã£ã¦æ–‡è¨€ãŒé•ã†å ´åˆãŒã‚ã‚‹ã®ã§æ³¨æ„ï¼‰
                const publishBtn = page.getByRole('button', { name: 'æŠ•ç¨¿', exact: true }); 
                // ã¾ãŸã¯ "å…¬é–‹"
                if (await publishBtn.isVisible()) {
                  await publishBtn.click();
                  console.log('âœ… æŠ•ç¨¿ãƒœã‚¿ãƒ³ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¾ã—ãŸ');
                } else {
                   await page.getByText('æŠ•ç¨¿ã™ã‚‹').click();
                }
                
              } else {
                console.log('ğŸ’¾ ä¸‹æ›¸ãä¿å­˜å‡¦ç†ã‚’é–‹å§‹...');
                // ä¸‹æ›¸ãä¿å­˜ãƒœã‚¿ãƒ³
                const draftBtn = page.getByRole('button', { name: 'ä¸‹æ›¸ãä¿å­˜' });
                if (await draftBtn.isVisible()) {
                  await draftBtn.click();
                } else {
                  // ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã®ä¸­ã«ã‚ã‚‹å ´åˆ
                  await page.locator('.editor-header-action-menu').click();
                  await page.waitForTimeout(500);
                  await page.getByText('ä¸‹æ›¸ãä¿å­˜').click();
                }
                
                // ã€Œä¸‹æ›¸ãã‚’ä¿å­˜ã—ã¾ã—ãŸã€ã‚’ç¢ºèª
                await page.waitForSelector('text=ä¸‹æ›¸ãã‚’ä¿å­˜ã—ã¾ã—ãŸ', { timeout: 10000 });
                console.log('âœ… ä¸‹æ›¸ãä¿å­˜å®Œäº†ã‚’ç¢ºèªã—ã¾ã—ãŸ');
              }

              // å¿µã®ãŸã‚ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚·ãƒ§ãƒƒãƒˆ
              await page.screenshot({ path: 'result.png' });
              console.log('ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚·ãƒ§ãƒƒãƒˆã‚’ä¿å­˜ã—ã¾ã—ãŸ: result.png');

            } catch (e) {
              console.error('âŒ ã‚¨ãƒ©ãƒ¼ç™ºç”Ÿ:', e);
              await page.screenshot({ path: 'error.png' });
              process.exit(1);
            }

            await browser.close();
          })();
          EOF
          
          node post.mjs
          
      - name: Upload screenshot (if any)
        if: ${{ steps.publish.outputs.screenshot != '' }}
        uses: actions/upload-artifact@v4
        with:
          name: note-screenshot
          path: ${{ steps.publish.outputs.screenshot }}
